from aws_privatekey import * # 예민한 정보는 별도 보관할 것

# 입력받고 보낼 메세지 토픽
TOPIC_STATUS  = "rpi/status"
TOPIC_MIC     = "mic/upload" # <- 현재 이거는 아직 안씀
TOPIC_CONTROL = "cmd/control"

# AI 음성성
SERVER_URL = "http://54.180.212.150/ai/predict"
DEVICE_ID  = "raspberrypi001"

from awscrt import io, mqtt, auth, http
from awsiot import mqtt_connection_builder
# AWS 연동

from serial.tools import list_ports

import time, json, threading, subprocess, serial, pyaudio, wave, datetime, requests, os


import io as std_io #aws io랑 겹쳐서 별도로 이름 넣음, 레코딩에 쓰이는 io임


#-------------------------------------------------------------

# IoT 제어 클래스

class Controller:
    def __init__(self, mqtt_connection, topic_status=TOPIC_STATUS):
        self.mqtt_connection = mqtt_connection
        self.topic_status = topic_status
        self.is_streaming = False
        self.camera_process = None
        
        self.PORT = "/dev/serial/by-id/usb-Arduino__www.arduino.cc__0043_8573531323335120D132-if00"   # 아두이노 포트
        self.BAUD = 9600             # 시리얼 통신 속도
        self.TIMEOUT = 1             # usb하고 연결 안됬을 때의 Time out
        
    
    def on_message_received(self, topic, payload, **kwargs):
        try:
            data = json.loads(payload.decode())
            # process() 호출
            response = self.process(data)
            if response:
                # 퍼블리시
                self.mqtt_connection.publish(
                    topic=self.topic_status,
                    payload=json.dumps(response),
                    qos=mqtt.QoS.AT_LEAST_ONCE
                )
                print("응답 전송:", response)
        except json.JSONDecodeError:
            print("Invalid JSON:", payload)
            
    
    def process(self, payload:dict) -> dict:
        command = payload.get("message")
        nowtime = datetime.datetime.now()
        time_stamp = {
            "date": nowtime.date().isoformat(),
            "time": nowtime.time().strftime("%H:%M:%S")
        }
        
        if command == "snack":
            self.snack_signal()
            return {"status":"snack_give", **time_stamp}
        
        elif command == "camera_on":
            self.start_camera_stream()
            self.is_streaming = True
            return {"status":"rpi_camera_on", **time_stamp}
            
        elif command == "camera_off":
            self.stop_camera_stream()
            self.is_streaming = False
            return {"status":"rpi_camera_off", **time_stamp}
            
        elif command == "speaker":
            self.play_speaker()

            return {"status":"user_sound", **time_stamp}
            
        else:
            print("알 수 없는 명령어")
            return {"status":"unknown_command", **time_stamp}
            
            
    def play_speaker(self):
        # 스피커 재생 코드
        print("사용자 목소리 재생")
        pass
    
    def stop_camera_stream(self):
        # 실행 중인 gst-launch 프로세스 종료
        subprocess.run(["pkill", "gst-launch-1.0"])
        print("카메라 스트리밍 종료")
    
    def start_camera_stream(self):
        pipeline = (
        "gst-launch-1.0 autovideosrc "
        "! videoconvert "
        "! video/x-raw,format=I420,width=640,height=480 "
        # x264enc 옵션을 한 덩어리로
        "! x264enc bframes=0 key-int-max=45 tune=zerolatency byte-stream=true speed-preset=ultrafast "
        # 1초마다 SPS/PPS 전송
        "! h264parse config-interval=1 "
        "! video/x-h264,stream-format=avc,alignment=au,profile=baseline "
        "! kvssink stream-name=rpi-video"
        )
    
        
        self.camera_process = subprocess.Popen(
            pipeline, 
            shell=True, 
            executable="/bin/bash",
            stdout=subprocess.DEVNULL,
            stderr=subprocess.DEVNULL
            )
        
        print(f"카메라 스트리밍 시작 (PID {self.camera_process.pid})")
        
    
    
    def snack_signal(self):                                     # 간식 주기 신호
        """ 포트 연결 > 전송 > 포트 닫기 순으로 동작함 """
    
        try:
            ser = serial.Serial(self.PORT, self.BAUD, timeout=self.TIMEOUT)
            time.sleep(2)
            ser.write(bytes([0xF1]))
        except serial.SerialException as e:
            print(f"시리얼 전송 실패 {self.PORT}: {e}")
        finally:
            if 'ser' in locals() and ser.is_open:
                ser.close()
        print("간식 주기 완료")
        

# 녹음 및 S3 업로드 클래스
# 파라미터(엑세스키, 시크릿키, 버킷이름, 리전이름=기본 아시아, S3 프리픽스)


class Recording:
    def __init__(self, server_url, device_id, record_seconds=2,
                 format=pyaudio.paInt16, channels=1, rate=16000, chunk=None):
        self.server_url = server_url
        self.device_id = device_id
        self.format = format
        self.channels = channels
        self.rate = rate
        # chunk: 프레임 크기, 지정 안 하면 1초 단위로 나눠서 처리
        self.chunk = chunk or self.rate * record_seconds
        self.audio = pyaudio.PyAudio()
        self.record_seconds = record_seconds

        self.stop_event = threading.Event()
        self.thread = None

    def record_audio(self):
        stream = self.audio.open(format=self.format,
                                 channels=self.channels,
                                 rate=self.rate,
                                 input=True,
                                 frames_per_buffer=self.chunk)
        frames = []
        # CHUNK 단위로 읽어서 WAV 버퍼에 바로 작성
        frames.append(stream.read(self.chunk))
        stream.stop_stream()
        stream.close()

        wav_buffer = std_io.BytesIO()
        with wave.open(wav_buffer, 'wb') as wf:
            wf.setnchannels(self.channels)
            wf.setsampwidth(self.audio.get_sample_size(self.format))
            wf.setframerate(self.rate)
            wf.writeframes(b''.join(frames))
        wav_buffer.seek(0)
        return wav_buffer

    def upload_to_server(self, wav_buffer):
        # Multipart/form-data 로 device_id 와 파일 전송
        files = {
            'file': ('audio.wav', wav_buffer, 'audio/wav')
        }
        data = {'device_id': self.device_id}
        try:
            resp = requests.post(self.server_url, files=files, data=data, timeout=10)
            print("서버 응답 코드:", resp.status_code)
            print("서버 응답 결과:", resp.text)
        except Exception as e:
            print("서버 전송 오류:", e)

    def _worker(self):
        while not self.stop_event.is_set():
            print("녹음 시작")
            wav_buf = self.record_audio()
            print("녹음 완료 -> 서버 업로드")
            self.upload_to_server(wav_buf)
            print(f"{self.record_seconds}초 대기\n")
            time.sleep(self.record_seconds)

    def start(self):
        if self.thread and self.thread.is_alive():
            print("녹음 실행 중")
            return
        print("녹음 스레드 시작")
        self.stop_event.clear()
        self.thread = threading.Thread(target=self._worker, daemon=True)
        self.thread.start()

    def stop(self):
        print("녹음 중지")
        self.stop_event.set()
        if self.thread:
            self.thread.join()
        self.audio.terminate()
        print("녹음 종료")

#------------------------------------------------------------- 여기부터 메인

def main():
    # AWS IoT MQTT 연결 준비
    event_loop_group = io.EventLoopGroup(1)
    host_resolver = io.DefaultHostResolver(event_loop_group)
    client_bootstrap = io.ClientBootstrap(event_loop_group, host_resolver)

    # MQTT 연결 설정
    mqtt_connection = mqtt_connection_builder.mtls_from_path(
        endpoint=ENDPOINT,
        cert_filepath=PATH_TO_CERT,
        pri_key_filepath=PATH_TO_KEY,
        ca_filepath=PATH_TO_ROOT,
        client_id=CLIENT_ID,
        clean_session=False,
        keep_alive_secs=30,
    )

    # 연결 시도
    print("conntecting aws iot core")
    mqtt_connection.connect().result()
    print("connected")
    
    recorder = Recording(
        server_url=SERVER_URL,
        device_id=DEVICE_ID,
        record_seconds=2
    )

    
    recorder.start()  # 2초 간격으로 녹음 -> 업로드 파이프라인 가동
    
    
    cont = Controller(mqtt_connection)
        
    mqtt_connection.publish(
        topic=TOPIC_STATUS,
        payload=json.dumps({"status":"ready"}),
        qos=mqtt.QoS.AT_LEAST_ONCE
    )
    
    # 구독중인 메세지들
    
    mqtt_connection.subscribe(
        topic=TOPIC_CONTROL,
        qos=mqtt.QoS.AT_LEAST_ONCE,
        callback=cont.on_message_received
    )

    # (필요하면 MIC 토픽도 같은 콜백으로)
    mqtt_connection.subscribe(
        topic=TOPIC_MIC,
        qos=mqtt.QoS.AT_LEAST_ONCE,
        callback=cont.on_message_received
    )
    

    # 대기
    print("메시지 대기 중")
    try:
        while True:
            time.sleep(1)       # cpu 점유율을 낮추기 위함
    except KeyboardInterrupt:
        print("연결 종료")
        
        mqtt_connection.publish(
        topic=TOPIC_STATUS,
        payload=json.dumps({"status":"program_off"}),
        qos=mqtt.QoS.AT_LEAST_ONCE
        )
        
        recorder.stop()
        cont.stop_camera_stream()
        mqtt_connection.disconnect().result()
        


if __name__ == "__main__":
    main()

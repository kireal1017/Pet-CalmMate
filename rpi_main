from aws_privatekey import * # ì˜ˆë¯¼í•œ ì •ë³´ëŠ” ë³„ë„ ë³´ê´€í•  ê²ƒ

# ì…ë ¥ë°›ê³  ë³´ë‚¼ ë©”ì„¸ì§€ í† í”½
TOPIC_STATUS  = "rpi/status"
TOPIC_MIC     = "mic/upload" # <- í˜„ì¬ ì´ê±°ëŠ” ì•„ì§ ì•ˆì”€
TOPIC_CONTROL = "cmd/control"


from awscrt import io, mqtt, auth, http
from awsiot import mqtt_connection_builder
# AWS ì—°ë™

from serial.tools import list_ports

import time, json, threading, subprocess, serial, pyaudio, wave, boto3, datetime, glob
import io as std_io #aws ioë‘ ê²¹ì³ì„œ ë³„ë„ë¡œ ì´ë¦„ ë„£ìŒ, ë ˆì½”ë”©ì— ì“°ì´ëŠ” ioì„


#-------------------------------------------------------------

# IoT ì œì–´ í´ë˜ìŠ¤

class Controller:
    def __init__(self, mqtt_connection, topic_status=TOPIC_STATUS):
        self.mqtt_connection = mqtt_connection
        self.topic_status = topic_status
        self.is_streaming = False
        self.camera_process = None
        
        self.PORT = "/dev/serial/by-id/usb-Arduino__www.arduino.cc__0043_8573531323335120D132-if00"   # ì•„ë‘ì´ë…¸ í¬íŠ¸
        self.BAUD = 9600             # ì‹œë¦¬ì–¼ í†µì‹  ì†ë„
        self.TIMEOUT = 1             # usbí•˜ê³  ì—°ê²° ì•ˆë¬ì„ ë•Œì˜ Time out
        
    
    def on_message_received(self, topic, payload, **kwargs):
        try:
            data = json.loads(payload.decode())
            # process() í˜¸ì¶œ
            response = self.process(data)
            if response:
                # í¼ë¸”ë¦¬ì‹œ
                self.mqtt_connection.publish(
                    topic=self.topic_status,
                    payload=json.dumps(response),
                    qos=mqtt.QoS.AT_LEAST_ONCE
                )
                print("ì‘ë‹µ ì „ì†¡:", response)
        except json.JSONDecodeError:
            print("Invalid JSON:", payload)
            
    
    def process(self, payload:dict) -> dict:
        command = payload.get("message")
        nowtime = datetime.datetime.now()
        time_stamp = {
            "date": nowtime.date().isoformat(),
            "time": nowtime.time().strftime("%H:%M:%S")
        }
        
        if command == "snack":
            self.snack_signal()
            return {"status":"snack_give", **time_stamp}
        
        elif command == "camera_on":
            self.start_camera_stream()
            self.is_streaming = True
            return {"status":"rpi_camera_on", **time_stamp}
            
        elif command == "camera_off":
            self.stop_camera_stream()
            self.is_streaming = False
            return {"status":"rpi_camera_off", **time_stamp}
            
        elif command == "speaker":
            self.play_speaker()

            return {"status":"user_sound", **time_stamp}
            
        else:
            print("ì•Œ ìˆ˜ ì—†ëŠ” ëª…ë ¹ì–´")
            return {"status":"unknown_command", **time_stamp}
            
            
    def play_speaker(self):
        # ìŠ¤í”¼ì»¤ ì¬ìƒ ì½”ë“œ
        print("ì‚¬ìš©ì ëª©ì†Œë¦¬ ì¬ìƒ")
        pass
    
    def stop_camera_stream(self):
        # ì‹¤í–‰ ì¤‘ì¸ gst-launch í”„ë¡œì„¸ìŠ¤ ì¢…ë£Œ
        subprocess.run(["pkill", "gst-launch-1.0"])
        print("ì¹´ë©”ë¼ ìŠ¤íŠ¸ë¦¬ë° ì¢…ë£Œ")
    
    def start_camera_stream(self):
        pipeline = (
        "gst-launch-1.0 autovideosrc "
        "! videoconvert "
        "! video/x-raw,format=I420,width=640,height=480 "
        "! x264enc bframes=0 key-int-max=45 tune=zerolatency "
        "byte-stream=true speed-preset=ultrafast "
        "! h264parse "
        "! video/x-h264,stream-format=avc,alignment=au,profile=baseline "
        "! kvssink stream-name=rpi-video"
        )
        
        self.camera_process = subprocess.Popen(
            pipeline, 
            shell=True, 
            executable="/bin/bash",
            stdout=subprocess.DEVNULL,
            stderr=subprocess.DEVNULL
            )
        
        print(f"[INFO] Camera streaming started (PID {self.camera_process.pid})")
        
    
    
    def snack_signal(self):                                     # ê°„ì‹ ì£¼ê¸° ì‹ í˜¸
        """ í¬íŠ¸ ì—°ê²° > ì „ì†¡ > í¬íŠ¸ ë‹«ê¸° ìˆœìœ¼ë¡œ ë™ì‘í•¨ """
    
        try:
            ser = serial.Serial(self.PORT, self.BAUD, timeout=self.TIMEOUT)
            time.sleep(2)
            ser.write(bytes([0xF1]))
        except serial.SerialException as e:
            print(f"ì‹œë¦¬ì–¼ ì „ì†¡ ì‹¤íŒ¨ {self.PORT}: {e}")
        finally:
            if 'ser' in locals() and ser.is_open:
                ser.close()
        print("ê°„ì‹ ì£¼ê¸° ì™„ë£Œ")
        

# ë…¹ìŒ ë° S3 ì—…ë¡œë“œ í´ë˜ìŠ¤
# íŒŒë¼ë¯¸í„°(ì—‘ì„¸ìŠ¤í‚¤, ì‹œí¬ë¦¿í‚¤, ë²„í‚·ì´ë¦„, ë¦¬ì „ì´ë¦„=ê¸°ë³¸ ì•„ì‹œì•„, S3 í”„ë¦¬í”½ìŠ¤)

class Recording:
    def __init__(self, aws_access_key, aws_secret_key, bucket_name, region_name='ap-northeast-2', s3_prefix='recordings/'):
        self.s3 = boto3.client(
            's3',
            aws_access_key_id = aws_access_key,
            aws_secret_access_key = aws_secret_key,
            region_name = region_name
        )
        self.bucket_name = bucket_name
        self.s3_prefix = s3_prefix

        self.format = pyaudio.paInt16
        self.channels = 1
        self.rate = 44100
        self.chunk = 1024
        self.audio = pyaudio.PyAudio()

        self.stop_event = threading.Event()
        self.thread = None

    def record_audio(self, duration_sec):
        stream = self.audio.open(format=self.format,
                                 channels=self.channels,
                                 rate=self.rate,
                                 input=True,
                                 frames_per_buffer=self.chunk)

        frames = []

        for _ in range(0, int(self.rate / self.chunk * duration_sec)):
            if self.stop_event.is_set():
                break
            data = stream.read(self.chunk)
            frames.append(data)

        stream.stop_stream()
        stream.close()

        wav_buffer = std_io.BytesIO()
        with wave.open(wav_buffer, 'wb') as wf:
            wf.setnchannels(self.channels)
            wf.setsampwidth(self.audio.get_sample_size(self.format))
            wf.setframerate(self.rate)
            wf.writeframes(b''.join(frames))

        wav_buffer.seek(0)
        return wav_buffer

    def upload_to_s3(self, buffer, key):
        try:
            self.s3.upload_fileobj(buffer, self.bucket_name, key)
            print(f"âœ… ì—…ë¡œë“œ ì™„ë£Œ: s3://{self.bucket_name}/{key}")
        except Exception as e:
            print(f"âŒ ì—…ë¡œë“œ ì‹¤íŒ¨: {e}")

    def _worker(self, duration_sec):
        while not self.stop_event.is_set():
            now = datetime.datetime.now()
            s3_key = self.s3_prefix + now.strftime("%Y-%m-%d_%H-%M-%S") + ".wav"
            buffer = self.record_audio(duration_sec)
            if not self.stop_event.is_set():
                self.upload_to_s3(buffer, s3_key)

    def start(self, record_seconds=3):
        if self.thread is None or not self.thread.is_alive():
            print("ğŸ” ë…¹ìŒ ìŠ¤ë ˆë“œ ì‹œì‘ë¨.")
            self.thread = threading.Thread(target=self._worker, args=(record_seconds,))
            self.thread.start()

    def stop(self):
        print("ğŸ›‘ ë…¹ìŒ ìŠ¤ë ˆë“œ ì¤‘ì§€ ìš”ì²­ë¨.")
        self.stop_event.set()
        self.thread.join()
        self.audio.terminate()
        print("âœ… ë…¹ìŒ ì¢…ë£Œ ì™„ë£Œ.")


#------------------------------------------------------------- ì—¬ê¸°ë¶€í„° ë©”ì¸

def main():
    # AWS IoT MQTT ì—°ê²° ì¤€ë¹„
    event_loop_group = io.EventLoopGroup(1)
    host_resolver = io.DefaultHostResolver(event_loop_group)
    client_bootstrap = io.ClientBootstrap(event_loop_group, host_resolver)

    # MQTT ì—°ê²° ì„¤ì •
    mqtt_connection = mqtt_connection_builder.mtls_from_path(
        endpoint=ENDPOINT,
        cert_filepath=PATH_TO_CERT,
        pri_key_filepath=PATH_TO_KEY,
        ca_filepath=PATH_TO_ROOT,
        client_id=CLIENT_ID,
        clean_session=False,
        keep_alive_secs=30,
    )

    # ì—°ê²° ì‹œë„
    print("conntecting aws iot core")
    mqtt_connection.connect().result()
    print("connected")
    
    recorder = Recording(
        aws_access_key=S3_AWS_ACCESS_KEY_ID,
        aws_secret_key=S3_AWS_SECRET_ACCESS_KEY,
        bucket_name=S3_BUCKET_NAME
    )
    
    recorder.start(record_seconds=2)  # 2ì´ˆ ê°„ê²©ìœ¼ë¡œ ë…¹ìŒ -> ì—…ë¡œë“œ íŒŒì´í”„ë¼ì¸ ê°€ë™
    
    
    cont = Controller(mqtt_connection)
        
    mqtt_connection.publish(
        topic=TOPIC_STATUS,
        payload=json.dumps({"status":"ready"}),
        qos=mqtt.QoS.AT_LEAST_ONCE
    )
    
    # êµ¬ë…ì¤‘ì¸ ë©”ì„¸ì§€ë“¤
    
    mqtt_connection.subscribe(
        topic=TOPIC_CONTROL,
        qos=mqtt.QoS.AT_LEAST_ONCE,
        callback=cont.on_message_received
    )

    # (í•„ìš”í•˜ë©´ MIC í† í”½ë„ ê°™ì€ ì½œë°±ìœ¼ë¡œ)
    mqtt_connection.subscribe(
        topic=TOPIC_MIC,
        qos=mqtt.QoS.AT_LEAST_ONCE,
        callback=cont.on_message_received
    )
    

    # ëŒ€ê¸°
    print("ë©”ì‹œì§€ ëŒ€ê¸° ì¤‘")
    try:
        while True:
            time.sleep(1)       # cpu ì ìœ ìœ¨ì„ ë‚®ì¶”ê¸° ìœ„í•¨
    except KeyboardInterrupt:
        print("ì—°ê²° ì¢…ë£Œ")
        
        mqtt_connection.publish(
        topic=TOPIC_STATUS,
        payload=json.dumps({"status":"program_off"}),
        qos=mqtt.QoS.AT_LEAST_ONCE
        )
        
        recorder.stop()
        cont.stop_camera_stream()
        mqtt_connection.disconnect().result()


if __name__ == "__main__":
    main()

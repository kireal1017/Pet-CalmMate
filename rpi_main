from aws_privatekey import * # 예민한 정보는 별도 보관할 것

# 디바이스 번호
DEVICE_ID  = "raspberrypi001"
DEVICE_CONNATION_CODE = "004001"

# 입력받고 보낼 메세지 토픽
TOPIC_STATUS  = "rpi/status"
TOPIC_MIC     = "mic/upload" # <- 현재 이거는 아직 안씀
TOPIC_CONTROL = "cmd/control"


from awscrt import io, mqtt, auth, http
from awsiot import mqtt_connection_builder
# AWS 연동

from serial.tools import list_ports

import time, json, threading, subprocess, pyaudio, wave, datetime, requests, os, pygame, board, neopixel, sys
import io as std_io #aws io랑 겹쳐서 별도로 이름 넣음, 레코딩에 쓰이는 io임
import RPi.GPIO as GPIO    # 스텝모터, LED 버튼 제어


# 버튼 핀
BUTTON_PIN = 17



# 스텝 핀 정의 빨주노초 순
IN1 = 24
IN2 = 23
IN3 = 22
IN4 = 27

# 부모 프로세스 먼저 종료
time.sleep(2)  # 잠시 대기
subprocess.run(["pkill", "-f", "start_setup.py"])
time.sleep(1)  # 잠시 대기

# GPIO 설정
GPIO.setmode(GPIO.BCM)
GPIO.setwarnings(False)
GPIO.setup(IN1, GPIO.OUT)
GPIO.setup(IN2, GPIO.OUT)
GPIO.setup(IN3, GPIO.OUT)
GPIO.setup(IN4, GPIO.OUT)
GPIO.setup(BUTTON_PIN, GPIO.IN, pull_up_down=GPIO.PUD_UP)

# 스텝 시퀀스
step_sequence = [
    [1,0,0,1],
    [1,0,0,0],
    [1,1,0,0],
    [0,1,0,0],
    [0,1,1,0],
    [0,0,1,0],
    [0,0,1,1],
    [0,0,0,1]
]

#-------------------------------------------------------------
# 전원 제어 클래스
# class PowerControl:
#     def __init__(self, button_pin=BUTTON_PIN, pixel_pin=PIXEL_PIN, num_pixels=NUM_PIXELS):
#         self.button_pin = button_pin
#         self.pixel_pin = pixel_pin
#         self.num_pixels = num_pixels
#         self.is_power_on = False
#         self.mainprocess = None
#         self.last_network_check = 0
#         self.NETWORK_CHECK_INTERVAL = 10  # 초 단위로 체크함
        
#         # 네오픽셀 설정
#         self.pixels = neopixel.NeoPixel(self.pixel_pin, self.num_pixels, brightness=0.3, auto_write=True, pixel_order=neopixel.GRB)
        
#         # 상태 색상
#         self.COLOR_OFF = (0, 0, 0)
#         self.COLOR_YELLOW = (255, 150, 0)
#         self.COLOR_RED = (255, 0, 0)
#         self.COLOR_GREEN = (0, 255, 0)
        
#         # 상태 변수
#         self.is_power_on = False
        
#         # GPIO 설정
#         GPIO.setmode(GPIO.BCM)
#         GPIO.setup(self.button_pin, GPIO.IN, pull_up_down=GPIO.PUD_UP)
        
        
#     def is_network_connected(self):
#         try:
#             result = subprocess.check_output(['nmcli', '-t', '-f', 'CONNECTIVITY', 'general'])
#             return result.strip() == b'full'
#         except subprocess.CalledProcessError:  # 네트워크 연결 실패시 false 반환
#             return False
        
#     def wait_for_network(self, timeout=60):
#         start = time.time()
#         while time.time() - start < timeout:
#             if self.is_network_connected():
#                 return True
#             self.pixels[0] = self.COLOR_YELLOW
#             time.sleep(0.3)
#             self.pixels[0] = self.COLOR_OFF
#             time.sleep(0.3)
#         return False
    
        
#-------------------------------------------------------------

# IoT 제어 클래스

class Controller:
    def __init__(self, mqtt_connection, topic_status=TOPIC_STATUS):
        self.mqtt_connection = mqtt_connection
        self.topic_status = topic_status
        self.is_streaming = False
        self.camera_process = None
        
        pygame.mixer.init()  # pygame 믹서 초기화
        self.music_No1 = "/home/kireal1017/petcalmmate_project/example_sound/No1_chopin-nocturne-op-9-no-2-classical-piano-321995.mp3"
        self.music_No2 = "/home/kireal1017/petcalmmate_project/example_sound/No2_soft-piano-music-322002.mp3"
        self.music_No3 = "/home/kireal1017/petcalmmate_project/example_sound/No3_waltz-in-a-minor.mp3"
        self.music_No4 = "/home/kireal1017/petcalmmate_project/example_sound/No4_angels-we-have-heard-on-high-grand-piano-french-christmas-carol-1881.mp3" # 실행시 버그 발생함함
        self.music_No5 = "/home/kireal1017/petcalmmate_project/example_sound/No5_komm-lieber-mai-und-mache-overbeck-mozart-come-dear-may-and-make-3468.mp3"
        self.music_playing = False  # 음악 재생 상태 플래그

    def on_message_received(self, topic, payload, **kwargs):
        try:
            data = json.loads(payload.decode())
            # process() 호출
            response = self.process(data)
            if response:
                # 퍼블리시
                self.mqtt_connection.publish(
                    topic=self.topic_status,
                    payload=json.dumps(response),
                    qos=mqtt.QoS.AT_LEAST_ONCE
                )
                print("응답 전송:", response)
        except json.JSONDecodeError:
            print("Invalid JSON:", payload)
            
    
    def process(self, payload:dict) -> dict:
        command = payload.get("message")
        nowtime = datetime.datetime.now()
        time_stamp = {
            "date": nowtime.date().isoformat(),
            "time": nowtime.time().strftime("%H:%M:%S")
        }
        
        if command == "snack":
            self.snack_signal()
            return {"status":"snack_give", **time_stamp}
        
        elif command == "camera_on":
            self.start_camera_stream()
            self.is_streaming = True
            return {"status":"rpi_camera_on", **time_stamp}
            
        elif command == "camera_off":
            self.stop_camera_stream()
            self.is_streaming = False
            return {"status":"rpi_camera_off", **time_stamp}
            
        elif command == "speaker":
            url = payload.get("url")
            print(f"sound: {url}")
            self.play_speaker(url)  # 사용자 목소리 재생
            return {"status":"user_sound", **time_stamp}
        
        elif command == "music":
            type_str = payload.get("type")          # 숫자 0 ~ 5까지
            try:
                type_value = int(type_str)          # type이 문자열로 오면 int로 변환
            except (TypeError, ValueError):
                print("타입 파싱 오류:", type_str)
                return {"status": "invalid_type_value", **time_stamp}
            
            if type_value == 0:
                self.stop_music()
                print("음악 종료")
                return {"status": "music_stopped", **time_stamp}
            elif 1 <= type_value <= 5:
                self.play_music(type_value)
                print(f"{type_value}번 음악 재생")
                return {"status": f"music_play_{type_value}", **time_stamp}
            else:
                print("타입 오류:", type_value)
                return {"status": "invalid_type_range", **time_stamp}
        else:
            print("알 수 없는 명령어", payload)
            return {"status":"unknown_command", **time_stamp}
            
            
    def play_speaker(self, url):
        # 스피커 재생 코드
        subprocess.run(["ffplay", "-nodisp", "-autoexit", url])
        print("사용자 목소리 재생")
        pass
    
    def play_music(self, type_value):
        # 음악 재생 코드
        print("음악 재생")
        if type_value == 1:
            pygame.mixer.music.load(self.music_No1)
        elif type_value == 2:
            pygame.mixer.music.load(self.music_No2)
        elif type_value == 3:
            pygame.mixer.music.load(self.music_No3)
        elif type_value == 4:
            pygame.mixer.music.load(self.music_No4)
        elif type_value == 5:
            pygame.mixer.music.load(self.music_No5)
        else:
            print("음악 타입 오류")
            return
        pygame.mixer.music.play(loops=0)  # 음악 재생
        self.music_playing = True
        return
    
    def stop_music(self):       # 음악 정지 코드
        if self.music_playing:
            pygame.mixer.music.stop()
            self.music_playing = False
            print("음악 정지")
        else:
            print("음악이 재생 중이 아님")

    def stop_camera_stream(self):
        # 실행 중인 gst-launch 프로세스 종료
        subprocess.run(["pkill", "gst-launch-1.0"])
        print("카메라 스트리밍 종료")
    
    def start_camera_stream(self):
        pipeline_kvs = (
            "ffmpeg -f v4l2 -framerate 30 -video_size 640x480 -i /dev/video0 -c:v libx264 -b:v 1000k -g 30 -keyint_min 30 -preset ultrafast -tune zerolatency -f flv rtmp://54.180.212.150/live/kvs-stream"

        # "gst-launch-1.0 autovideosrc "
        # "! videoconvert "
        # "! video/x-raw,format=I420,width=640,height=480 "
        # # x264enc 옵션을 한 덩어리로
        # "! x264enc bframes=0 key-int-max=45 tune=zerolatency byte-stream=true speed-preset=ultrafast "
        # # 1초마다 SPS/PPS 전송
        # "! h264parse config-interval=1 "
        # "! video/x-h264,stream-format=avc,alignment=au,profile=baseline "
        # "! kvssink stream-name=rpi-video"
        )
    
        
        self.camera_process = subprocess.Popen(
            pipeline_kvs, 
            shell=True,
            executable="/bin/bash",
            stdout=subprocess.DEVNULL,
            stderr=subprocess.DEVNULL
            )
        
        print(f"카메라 스트리밍 시작 (PID {self.camera_process.pid})")
        
    
    
    def snack_signal(self):                                     # 간식 주기 신호
        steps_per_90_deg = 400
        for i in range(steps_per_90_deg):
            for step in step_sequence:
                GPIO.output(IN1, step[0])
                GPIO.output(IN2, step[1])
                GPIO.output(IN3, step[2])
                GPIO.output(IN4, step[3])
                time.sleep(0.001)
        print("간식 주기 완료")
        

# 녹음 세션 --------------------------------------------------------------------

class Recording:
    def __init__(self, server_url, device_id, record_seconds=2,
                 format=pyaudio.paInt16, channels=1, rate=16000, chunk=None):
        self.server_url = server_url
        self.device_id = device_id
        self.format = format
        self.channels = channels
        self.rate = rate
        # chunk: 프레임 크기, 지정 안 하면 1초 단위로 나눠서 처리
        self.chunk = chunk or self.rate * record_seconds
        self.audio = pyaudio.PyAudio()
        self.record_seconds = record_seconds

        self.stop_event = threading.Event()
        self.thread = None

    def record_audio(self):
        stream = self.audio.open(format=self.format,
                                 channels=self.channels,
                                 rate=self.rate,
                                 input=True,
                                 frames_per_buffer=self.chunk)
        frames = []
        # CHUNK 단위로 읽어서 WAV 버퍼에 바로 작성
        frames.append(stream.read(self.chunk))
        stream.stop_stream()
        stream.close()

        wav_buffer = std_io.BytesIO()
        with wave.open(wav_buffer, 'wb') as wf:
            wf.setnchannels(self.channels)
            wf.setsampwidth(self.audio.get_sample_size(self.format))
            wf.setframerate(self.rate)
            wf.writeframes(b''.join(frames))
        wav_buffer.seek(0)
        return wav_buffer

    def upload_to_server(self, wav_buffer):
        # Multipart/form-data 로 device_id 와 파일 전송
        files = {
            'file': ('audio.wav', wav_buffer, 'audio/wav')
        }
        data = {'device_id': self.device_id}
        try:
            resp = requests.post(self.server_url, files=files, data=data, timeout=20) # 서버 타임 아웃 시간 설정
            print("서버 응답 코드:", resp.status_code)
            print("서버 응답 결과:", resp.text)
        except Exception as e:
            print("서버 전송 오류:", e)

    def _worker(self):
        while not self.stop_event.is_set():
            print("녹음 시작")
            wav_buf = self.record_audio()
            print("녹음 완료 -> 서버 업로드")
            self.upload_to_server(wav_buf)
            print(f"{self.record_seconds}초 대기\n")
            time.sleep(self.record_seconds)

    def start(self):
        if self.thread and self.thread.is_alive():
            print("녹음 실행 중")
            return
        print("녹음 스레드 시작")
        self.stop_event.clear()
        self.thread = threading.Thread(target=self._worker, daemon=True)
        self.thread.start()

    def stop(self):
        print("녹음 중지")
        self.stop_event.set()
        if self.thread:
            self.thread.join()
        self.audio.terminate()
        print("녹음 종료")

#------------------------------------------------------------- 여기부터 메인


def main():
    # 전원버튼 제어항목
    press_start = 0
    was_pressed = False
    long_press_handled = False
        
    # AWS IoT MQTT 연결 준비
    event_loop_group = io.EventLoopGroup(1)
    host_resolver = io.DefaultHostResolver(event_loop_group)
    client_bootstrap = io.ClientBootstrap(event_loop_group, host_resolver)

    # MQTT 연결 설정
    mqtt_connection = mqtt_connection_builder.mtls_from_path(
        endpoint=ENDPOINT,
        cert_filepath=PATH_TO_CERT,
        pri_key_filepath=PATH_TO_KEY,
        ca_filepath=PATH_TO_ROOT,
        client_id=CLIENT_ID,
        clean_session=False,
        keep_alive_secs=30,
    )

    # 연결 시도
    print("conntecting aws iot core")
    mqtt_connection.connect().result()
    print("connected")
    
    recorder = Recording(
        server_url=SERVER_URL,
        device_id=DEVICE_ID,
        record_seconds=3                        # 녹음 시간 (초 단위)
    )

    
    # recorder.start()  # 2초 간격으로 녹음 -> 업로드 파이프라인 가동
    
    
    cont = Controller(mqtt_connection)
        
    mqtt_connection.publish(
        topic=TOPIC_STATUS,
        payload=json.dumps({"status":"ready", "device_id": DEVICE_ID, "connection_code": DEVICE_CONNATION_CODE}),
        qos=mqtt.QoS.AT_LEAST_ONCE
    )
    
    # 구독중인 메세지들
    mqtt_connection.subscribe(
        topic=TOPIC_CONTROL,
        qos=mqtt.QoS.AT_LEAST_ONCE,
        callback=cont.on_message_received
    )

    # (필요하면 MIC 토픽도 같은 콜백으로)
    mqtt_connection.subscribe(
        topic=TOPIC_MIC,
        qos=mqtt.QoS.AT_LEAST_ONCE,
        callback=cont.on_message_received
    )
    

    # 대기
    print("메시지 대기 중")
    try:
        while True:
            state = GPIO.input(BUTTON_PIN)

            if state == GPIO.LOW:
                if not was_pressed:
                    was_pressed = True
                    press_start = time.time()
                    print("버튼 누름 시작")

                if time.time() - press_start >= 3 and not long_press_handled:
                    print("3초 이상 버튼 눌림 → 부모 실행 & 자식 종료")
                    long_press_handled = True
                    
                    
                    mqtt_connection.publish(
                    topic=TOPIC_STATUS,
                    payload=json.dumps({"status": "program_off", "device_id": DEVICE_ID, "connection_code": DEVICE_CONNATION_CODE}),
                    qos=mqtt.QoS.AT_LEAST_ONCE
                    )
                    recorder.stop()
                    cont.stop_camera_stream()
                    mqtt_connection.disconnect().result()
                    GPIO.cleanup()
                    time.sleep(0.1)  # GPIO 정리 후 잠시 대기

                    # 부모 실행
                    subprocess.Popen(
                        ["sudo", "python3", "/home/kireal1017/petcalmmate_project/start_setup.py"],
                        stdout=subprocess.DEVNULL,
                        stderr=subprocess.DEVNULL,
                        preexec_fn=os.setsid
                    )

                    # 자식 종료
                    sys.exit(0)

            elif state == GPIO.HIGH and was_pressed:
                was_pressed = False
                long_press_handled = False
                print("버튼 뗌")
            time.sleep(0.01)       # cpu 점유율을 낮추기 위함
            
    
    except KeyboardInterrupt:
        print("연결 종료")
        
        mqtt_connection.publish(
            topic=TOPIC_STATUS,
            payload=json.dumps({"status": "program_off", "device_id": DEVICE_ID, "connection_code": DEVICE_CONNATION_CODE}),
            qos=mqtt.QoS.AT_LEAST_ONCE
        )
        
        recorder.stop()
        cont.stop_camera_stream()
        mqtt_connection.disconnect().result()
        GPIO.cleanup()

if __name__ == "__main__":
    main()

